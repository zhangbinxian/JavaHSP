### 类变量和类方法
#### 类变量(静态变量 static修饰)

1. static变量是同一个类所有对象共享的
2. static类变量，在类加载的时候就生成了
```java
// static 定义语法
public static int count=0;
static public int count=0;
```
如何访问类变量
- 类名.类变量名
- 对象名.类变量名

类变量使用细节
1. 什么时候使用类变量
当我们需要让某个类所有的实例对象共享一个变量时
2. 类变量和实例变量的区别
类变量该类所有对象共享，实例变量是每个对象独享
3. static修饰的才是类变量(静态变量)
4. 访问类变量 (1)类名.类变量名，(2)对象名.类变量名
5. 访问类变量需要遵循修饰符的访问范围
6. 类变量在类加载的时候就初始化了，也就是说，即便没有创建对象，只要类加载了，就可以使用
7. 类变量的生命周期是随类的加载开始，随类的消亡而销毁

#### 类方法
类方法(静态方法)

```java
// 访问修饰符 static 数据返回类型 方法名(){}
public static void func1(){}
// static 访问修饰符 数据返回类型 方法名(){}
static public void func1(){}
```

类方法的调用
- 类名.类方法
- 对象名.类方法

类方法使用细节
1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法去
2. 类方法中无this的参数，普通方法中隐含this的参数
3. 类方法的调用: (1)类名.类方法,(2)对象名.类方法
4. 普通方法和对象有关，需要通过对象名调用，不能通过类名调用
5. 类方法中不允许使用和对象有关的关键字，this，super
6. 类(静态)方法中只能访问静态变量或静态方法

7. 非静态方法可以访问静态成员和非静态成员
### main方法当中static
- main是由java虚拟机调用
- java虚拟机调用main，所以main是public
- java虚拟机在执行main方法时，不必创建对象，所以是static
- main接收String类型的数组参数，该数组中保存执行java命令时，传递给所运行类的参数
- java 执行的程序 参数1 参数2 参数3
### 代码块
代码块又称 初始化块，属于类中的成员，类似方法，将逻辑语句封装在方法体中，通过{}包围起来

代码块与方法不同，没有方法名，没有返回值，没有参数，只要方法体，不用通过对象或者类显示调用，而是加载类时，或创建对象是隐式调用

```java
//基本语法
[修饰符]{
    代码
};
```

- 修饰符可选，要写的化，也只能写static
- 代码块分两类，有static静态代码块，没有static普通代码块
- 逻辑语句可以是任何逻辑语句(输出，输入，方法调用，循环，判断)
- ;号可写，可不写

#### 代码块的好处
1. 相当于另外一种形式的构造器(对构造器的补充机制)，可以做初始化的操作
2. 如果多个构造器中都要重复的语句，可以抽取到初始化块中，提高代码重用性
3. 演示案例CodeBlock.java
4. 代码块调用，优先于构造器

#### 代码块注意事项
- 静态代码块，作用就是对类进行初始化，它会随着类的加载而执行，并且只执行一次
- 普通代码块，每创建一个对象，就执行
- 类什么时候加载 1，创建对象实例时(new)。2，创建子类对象实例，父类也会被加载。3，使用类的静态成员时(属性，方法)
- 普通的代码块，在创建对象实例时，会被隐式调用 1，被创建一次，就调用一次。2，如果只是使用类的静态成员时，普通代码块并不会执行


- 创建一共对象时，在一个类 调用顺序
```java
// 1,调用静态代码块和静态属性初始化(静态代码块和静态属性初始化的调用优先级一样，)
// 如果有多个静态代码块和静态属性初始化，则按照定义的顺序调用

// 2,调用普通代码块和普通属性的初始化(普通代码块和普通属性的初始化的调用优先级一样，)
// 如果有多个普通代码块和普通属性初始化，则按照定义的顺序调用

// 3,调用构造方法

// 静态---普通---构造器
```

- 构造器的最前面其实隐含了super()和调用普通代码块，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块的执行

- 创建一个(多个)对象时，在父子类 调用顺序<br>
创建多个对象时候，静态代码块只执行一次
```java
// 代码块执行顺序

// 1 父类的静态代码块和静态属性初始化(优先级一样，如果多个按照定义顺序执行)
// 2 子类的静态代码块和静态属性初始化(优先级一样，如果多个按照定义顺序执行)
// 3 父类的普通代码块和普通属性初始化(优先级一样，如果多个按照定义顺序执行)
// 4 父类的构造器方法
// 5 子类的普通代码块和普通属性初始化(优先级一样，如果多个按照定义顺序执行)
// 6 子类的构造器方法

```
- 静态代码块只能调用静态成员，普通代码块可以调用任意成员
### 单例设计模式
单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一共对象实例，并且该类只提供一个取得其对象实例的方法
单例模式的实现步骤
1. 构造器私有化，防止在类的外面new对象
2. 类的内部创建对象
3. 向外暴露一个静态的公共方法，getInstance，get实例
4. 代码实现

#### 两种单例设计模式
1. 饿汉模式
- 饿汉式在类加载就创建了对象实例
- 饿汉式不存在线程安全
- 饿汉式存在浪费资源的可能,因为如果程序员一个对象实例都没有使用,那么创建的对象就浪费了

2. 懒汉模式
- 懒汉式是在使用时创建对象
- 懒汉式存在线程安全
- 懒汉式只有使用时,才创建对象,不会浪费资源

### final关键字
final最后的,最终的

final可以修饰类,属性,方法,局部变量

在某些情况下,有以下需求时,就会使用final
1. 当不希望类被继承时
2. 当不希望父类的某个方法被子类覆盖/重写时,
3. 当不希望类的某个属性被修改时
4. 当不希望某个局部变量被修改

#### final细节
1. final修饰的属性又称常量,一般使用大写命名,NUM,PI,RATE,XX_XX...
2. final修饰的属性在定义时,必须赋值,并且以后都不能修改<br>
1.定义时,public final double PI=3.14<br>
2.在构造器中<br>
3.在代码块中  
3. 如果final修饰的属性是静态的,则初始化位置只能是<br>
1.定义时<br>
2.在静态代码块当中,不能在构造器中<br>
4. final类不能被继承,但是可以实例化对象
5. 如果类不是final类,但是含有final方法,则该方法虽然不能重写,但是可以被继承

6. 一般来说,如果一个类已经是final类,则就没必要再将方法修饰成final
7. final不能修饰构造器
8. final和static往往搭配使用,效率更高,不会导致类加载,底层编译器做了优化处理
9. 包装类(Integer,Double,Float等)都是final类,String也是final类

### 抽象类

### 接口

### 内部类

