### 类变量和类方法
#### 类变量(静态变量 static修饰)

1. static变量是同一个类所有对象共享的
2. static类变量，在类加载的时候就生成了
```java
// static 定义语法
public static int count=0;
static public int count=0;
```
如何访问类变量
- 类名.类变量名
- 对象名.类变量名

类变量使用细节
1. 什么时候使用类变量
当我们需要让某个类所有的实例对象共享一个变量时
2. 类变量和实例变量的区别
类变量该类所有对象共享，实例变量是每个对象独享
3. static修饰的才是类变量(静态变量)
4. 访问类变量 (1)类名.类变量名，(2)对象名.类变量名
5. 访问类变量需要遵循修饰符的访问范围
6. 类变量在类加载的时候就初始化了，也就是说，即便没有创建对象，只要类加载了，就可以使用
7. 类变量的生命周期是随类的加载开始，随类的消亡而销毁

#### 类方法
类方法(静态方法)

```java
// 访问修饰符 static 数据返回类型 方法名(){}
public static void func1(){}
// static 访问修饰符 数据返回类型 方法名(){}
static public void func1(){}
```

类方法的调用
- 类名.类方法
- 对象名.类方法

类方法使用细节
1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法去
2. 类方法中无this的参数，普通方法中隐含this的参数
3. 类方法的调用: (1)类名.类方法,(2)对象名.类方法
4. 普通方法和对象有关，需要通过对象名调用，不能通过类名调用
5. 类方法中不允许使用和对象有关的关键字，this，super
6. 类(静态)方法中只能访问静态变量或静态方法

7. 非静态方法可以访问静态成员和非静态成员
### main方法当中static
- main是由java虚拟机调用
- java虚拟机调用main，所以main是public
- java虚拟机在执行main方法时，不必创建对象，所以是static
- main接收String类型的数组参数，该数组中保存执行java命令时，传递给所运行类的参数
- java 执行的程序 参数1 参数2 参数3
### 代码块
代码块又称 初始化块，属于类中的成员，类似方法，将逻辑语句封装在方法体中，通过{}包围起来

代码块与方法不同，没有方法名，没有返回值，没有参数，只要方法体，不用通过对象或者类显示调用，而是加载类时，或创建对象是隐式调用

```java
//基本语法
[修饰符]{
    代码
};
```

- 修饰符可选，要写的化，也只能写static
- 代码块分两类，有static静态代码块，没有static普通代码块
- 逻辑语句可以是任何逻辑语句(输出，输入，方法调用，循环，判断)
- ;号可写，可不写

#### 代码块的好处
1. 相当于另外一种形式的构造器(对构造器的补充机制)，可以做初始化的操作
2. 如果多个构造器中都要重复的语句，可以抽取到初始化块中，提高代码重用性
3. 演示案例CodeBlock.java
4. 代码块调用，优先于构造器

#### 代码块注意事项
- 静态代码块，作用就是对类进行初始化，它会随着类的加载而执行，并且只执行一次
- 普通代码块，每创建一个对象，就执行
- 类什么时候加载 1，创建对象实例时(new)。2，创建子类对象实例，父类也会被加载。3，使用类的静态成员时(属性，方法)
- 普通的代码块，在创建对象实例时，会被隐式调用 1，被创建一次，就调用一次。2，如果只是使用类的静态成员时，普通代码块并不会执行


- 创建一共对象时，在一个类 调用顺序
```java
// 1,调用静态代码块和静态属性初始化(静态代码块和静态属性初始化的调用优先级一样，)
// 如果有多个静态代码块和静态属性初始化，则按照定义的顺序调用

// 2,调用普通代码块和普通属性的初始化(普通代码块和普通属性的初始化的调用优先级一样，)
// 如果有多个普通代码块和普通属性初始化，则按照定义的顺序调用

// 3,调用构造方法

// 静态---普通---构造器
```

- 构造器的最前面其实隐含了super()和调用普通代码块，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块的执行

- 创建一个(多个)对象时，在父子类 调用顺序<br>
创建多个对象时候，静态代码块只执行一次
```java
// 代码块执行顺序

// 1 父类的静态代码块和静态属性初始化(优先级一样，如果多个按照定义顺序执行)
// 2 子类的静态代码块和静态属性初始化(优先级一样，如果多个按照定义顺序执行)
// 3 父类的普通代码块和普通属性初始化(优先级一样，如果多个按照定义顺序执行)
// 4 父类的构造器方法
// 5 子类的普通代码块和普通属性初始化(优先级一样，如果多个按照定义顺序执行)
// 6 子类的构造器方法

```
- 静态代码块只能调用静态成员，普通代码块可以调用任意成员
### 单例设计模式
单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一共对象实例，并且该类只提供一个取得其对象实例的方法
单例模式的实现步骤
1. 构造器私有化，防止在类的外面new对象
2. 类的内部创建对象
3. 向外暴露一个静态的公共方法，getInstance，get实例
4. 代码实现

#### 两种单例设计模式
1. 饿汉模式
- 饿汉式在类加载就创建了对象实例
- 饿汉式不存在线程安全
- 饿汉式存在浪费资源的可能,因为如果程序员一个对象实例都没有使用,那么创建的对象就浪费了

2. 懒汉模式
- 懒汉式是在使用时创建对象
- 懒汉式存在线程安全
- 懒汉式只有使用时,才创建对象,不会浪费资源

### final关键字
final最后的,最终的

final可以修饰类,属性,方法,局部变量

在某些情况下,有以下需求时,就会使用final
1. 当不希望类被继承时
2. 当不希望父类的某个方法被子类覆盖/重写时,
3. 当不希望类的某个属性被修改时
4. 当不希望某个局部变量被修改

#### final细节
1. final修饰的属性又称常量,一般使用大写命名,NUM,PI,RATE,XX_XX...
2. final修饰的属性在定义时,必须赋值,并且以后都不能修改<br>
1.定义时,public final double PI=3.14<br>
2.在构造器中<br>
3.在代码块中  
3. 如果final修饰的属性是静态的,则初始化位置只能是<br>
1.定义时<br>
2.在静态代码块当中,不能在构造器中<br>
4. final类不能被继承,但是可以实例化对象
5. 如果类不是final类,但是含有final方法,则该方法虽然不能重写,但是可以被继承

6. 一般来说,如果一个类已经是final类,则就没必要再将方法修饰成final
7. final不能修饰构造器
8. final和static往往搭配使用,效率更高,不会导致类加载,底层编译器做了优化处理
9. 包装类(Integer,Double,Float等)都是final类,String也是final类

### 抽象类 abstract

- 用abstract修饰一个类时，这个类就是抽象类
```java
访问修饰符 abstract 类名{}
```
- 用abstract修饰一个方法时，这个方法就是抽象方法
```java
访问修饰符 abstract 返回类型 方法名(参数列表);
```
- 抽象类的价值更多是在于设计，设计者设计好后，让子类继承并实现
- 在框架和设计模式使用较多

#### 使用细节
1. 抽象类不能被实例化
2. 抽象类不一定含有abstract方法，抽象类可以没有abstract方法
3. 一旦含有abstract方法，则这个类必须是abstract类
4. abstract只能修复类和方法，不能修饰其他
5. 抽象类可以有任意成员(抽象类还是类)，可以有构造器，属性，方法等
6. 抽象方法不能有主体，即不能有{},public abstract void hi(); 
7. 如果一个类继承了抽象类，则它必须实现抽象类的所以抽象方法，除非它自己也声明为abstract类
8. 抽象方法不能使用private，final，static修复，因为这些关键字都是和重写相违背的

### 接口
接口就是给出一些没有实现的方法，封装到一起，到某个类要使用时，再根据具体情况实现方法

```java
interface 接口名{
    // 属性
    // 方法(1.抽象方法，2.默认实现方法，3，静态方法)
    
}
```
```java
class 类名 implements 接口{
    // 自己属性
    // 自己方法
    // 必须实现的接口的抽象方法
}
```
在jdk7之前，接口里的所有方法都没有方法体，即都是抽象方法<br>
在jdk8之后，可以有静态方法，默认方法，即在接口当中可以有方法的具体实现，需要家default关键字修饰

####接口使用细节
- 接口不能实例化
- 接口当中所有方法都是public，接口中的抽象方法，可以不用abstract修饰
```java
void add();
// 等价于
abstract void add();
```
- 一个普通类实现接口，就要将该接口的所有方法都实现
- 抽象类实现接口，可以不用实现接口的方法

- 一个类可以同时实现多个接口
- 接口中的属性，只能是final，而且是public static final 修饰符
```java
int a=1;
// 实际上是
public static final int a=1;
```
- 接口中属性的访问形式: 接口名.属性
- 一个接口不能继承其他的类，但是可以继承多个别的接口
```java
interface A extends B,C{}
```
- 接口的修饰符，只能是public和默认

#### 可以理解为，接口是对java单继承的一种补充机制
实例 chapter09.demo07 demo04.java

#### 实现接口Vs继承类
##### 继承
- 继承在于，解决代码复用性和可维护性
- 继承满足条件 is-a
##### 实现接口
- 接口实现在于，设计，设计好各种规范(方法),让其他类去实现这些方法，更加灵活
- 接口满足条件 like-a

#### 接口的多态特性
- 多态参数(USB usb),既可以接收对象,手机，相机，等等
- 多态数组,USB数组存放phone，相机对象，，变量USB数组，对象不同，调用不同的方法
- 接口存在多态传递现象
### 内部类(四种)
定义在外部局部位置上，比如方法内
- 局部内部类 (有类名)
- 匿名内部类 (没有类名)

定义在外部类的成员位置上
- 成员内部类 (没有static修饰)
- 静态内部类 (使用static修饰)

#### 介绍
一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),
嵌套其他类的类称为外部类(outer class).内部类的最大特点是可以直接访问私有属性，并体现类与类之间的包含关系

基本语法
```java
// 基本语法
// 外部类
class Outer{
    // 内部类
    class Inner{
    }
}

// 其他类
class Other{
    
}
```
#### 局部内部类
- 可以直接访问外部类的所有成员，包括私有private
- 不能添加访问修饰符，因为它是一个局部变量。但可以使用final修饰
- 作用域 仅仅在定义它的方法或者代码块中
- 局部内部类.访问--->外部类的成员 (直接访问)
- 外部类.访问--->局部内部类的成员 (创建对象，再访问，且必须在作用域内)
- 外部其他类.不能访问--->局部内部类，(因为局部内部类的地位是一个局部变量)
- 如果外部类和局部内部类的成员重名，默认遵循就近原则，如果要访问外部类的成员，则可以使用(外部类名.this成员)去访问

#### 匿名内部类
- 匿名内部类是定义在外部类的局部位置(方法，代码块中)，并且没有类名
```java
// 基本语法
new 接口或者类(参数列表){
    类体
};
```
- 匿名内部类既是一个类，也是一个对象，既有定义类的特征也有创建对象的特征
```java
//===============================
new A(){
    @Override
    public void cry(){
        Systrm.out.println("hello");
    }
}.cry();
//===============================
A a=new A(){
    @Override
    public void cry(){
        Systrm.out.println("hello");
    }
};
a.cry();
```
- 可以直接访问外部类的所有成员，包括私有
- 不能添加访问修饰符，因为它是一个局部变量
- 作用域 仅仅在定义它的方法或者代码块中
- 匿名内部类.访问--->外部类的成员 (直接访问)
- 外部其他类.不能访问--->局部内部类，(因为匿名内部类的地位是一个局部变量)
- 如果外部类和匿名内部类的成员重名，默认遵循就近原则，匿名内部类如果要访问外部类的成员，则可以使用(外部类名.this成员)去访问
#### 成员内部类
成员内部类定义在外部类成员位置，并且没有static修饰

- 成员内部类可以直接访问外部类的所有成员，包括私有
```java
class Outer01{
    private int n1=10;
    public String name="zzz";
    
    class Inner01{
        public void say(){
            System.out.println("n1="+n1);
            System.out.println("name="+name);
        }
    }
    
    public void f1(){
        Inner01 inner01=new Inner01();
        inner01.say();
    }
}
```
- 可以添加任意访问修饰符，因为它的地位是一个成员
- 作用域 和外部类的其他成员一样，为整个类体，在外部类的成员方法中创建成员内部类对象，再调用方法
- 成员内部类.访问--->外部类(直接访问)
- 外部类.访问--->内部类(创建对象，再访问)
- 外部其他类.访问--->成员内部类
- 内部类和外部类的成员重名，内部类访问时，遵循就近原则，如果要访问外部类的成员，则可以使用(外部类名.this成员)访问

#### 静态内部类
静态内部类定义在外部类成员位置，并且使用static修饰

- 静态内部类可以直接访问外部类的所有```静态```成员，包括私有，不能访问非静态成员
- 可以添加任意访问修饰符，因为它的地位是一个成员
- 作用域 同类的其他成员，为整个整体
- 静态内部类.访问--->外部类的静态属性(直接访问)
- 外部类.访问--->静态内部类(创建对象，再访问)
- 外部其他类.访问--->成员内部类
- 内部类和外部类的成员重名，内部类访问时，遵循就近原则，如果要访问外部类的成员，则可以使用(外部类名.成员)访问

