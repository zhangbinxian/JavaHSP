### 类与对象
三大特性
1. 封装
2. 继承
3. 多态

类的属性细节
- 定于语法 访问修饰符 属性类型 属性名称<br>
private int age;
- 属性的定义类可以是任意类型，包含基本类型和引用类型
- 属性如果不赋值的话，有默认值，规则和数组一致
``` 
int 0,short 0,byte 0,long 0,
float 0.0,double 0.0,
char \u000,
boolean false,
String null.
```
- 访问修饰符一共四种<br>
public, protected, 默认, private


类与对象
创建一个对象
``` 
1.先声明再创建
People people1;         声明一共变量，此时变量在栈区域，指向地址为null
people1=new People;     创建了一共对象，对象在堆区域(有了地址)，people1指向了这个地址，属性部分在方法区(方法区，常量池记录值，并且有一个地址)，部分在堆（如，int）
==================================
2.直接创建
People people2=new People;  
创建了一个对象，people2在栈，并且有一个地址，指向堆，堆其实才是真正的对象
```

类与对象内存分配机制
```
public class demo02 {
    public static void main(String[] args) {
        P p1=new P();
        p1.Name="xiaoming";
        p1.Age=19;

        P p2=p1;        //p2指向的地址为null，但p2=p1,既把p1赋值给了p2，p2指向p1
        System.out.println(p2.Name+" "+p2.Age);
    }
}
class P{
    String Name;
    int Age;
}
====================================
结果
xiaoming 19
====================================
```

### 类与对象的内存分配机制
#### java内存结构
- 栈 一般存放基本数据结构(局部变量)
- 堆 存放对象(People p1,数组等)
- 方法区 常量池(常量,比如字符串),类加载信息
#### java创建对象流程
``` 
People p=new People();
p.name="liming";
p.age=20;
```
1. 先加载People类信息(属性和方法信息，只会加载一次)
2. 在堆中分配空间，进行默认初始化(0,0.0,null,false等)
3. 把地址赋值给(栈的)p,p指向对象(堆)
4. 进行指定初始化,p.name=‘liming’,p.age=20;

### 成员方法
``` 
访问修饰符 返回数据类型 方法名 (形参列表...){
    语句;
    return 返回值；
}
=====================
public int getSum(int a,int b){
    int c=a+b;
    return c;
}
```
1. 形参列表：表示成员方法的输入getSum(int a,int b);可以有多个参数，也可以没有参数
2. 返回数据类型：表示成员方法的输出，void表示没有返回值
3. return 不是必须的
4. 方法主体：为了实现某一功能

成员方法细节
- 访问修饰符(4种)public, protected, 默认, private
- 一个方法最多一个返回值,如果要返回多个值，则返回值类型可以是数组
- 返回值类型可以是任意类型，包括基本类型和引用类型(数组,对象)
- 如果方法要求 有```返回值``` 则```return 值```必须与返回数据类型一致或兼容(可以自动类型转换)
- 如果是void，则方法体中可以没有return语句,或者只写return;
- 方法名遵循```驼峰法```，如getSum();
- 在调用方法时,传参时，要传入形参相同,或者兼容的参数
- 方法体里面实现功能的具体语句,可以是输入，输出，变量，运算，分支，循环，方法调用，但是不能在里面再定义方法(方法不能嵌套定义)
- 接上一条,在方法2里面调用方法1,直接调用，不用创建对象
- 接上上一条,在方法2里面不能在写方法体

- 跨类中的方法a调用b类的方法，需要通过对象名调用


方法的作用
- 解决代码冗余
- 封装代码，方便调用

成员方法的传参机制
- 基本数据类型,传递的是值(值拷贝),形参的任何改变不影响实参
``` 
int a = 12;
int b = 21;
AA aa = new AA();
aa.swap(a, b);
//形参的改变,不影响实参
System.out.println("main当中a=" + a + ",b=" + b);

class AA {
    public void swap(int a, int b) {
        System.out.println("交换前a=" + a + ",b=" + b);
        int temp = a;
        a = b;
        b = temp;

        System.out.println("交换后a=" + a + ",b=" + b);
    }
}
```
- 引用数据类型,传递的是地址,形参的改变会影响实参
``` 

BB bb = new BB();
int[] Array = {1, 2, 3};
System.out.println("原先Array");
for (int i = 0; i < Array.length; i++) {
    System.out.print(Array[i] + " ");
}
System.out.println();

bb.array(Array);
System.out.println("调用方法后Array");
for (int i = 0; i < Array.length; i++) {
    System.out.print(Array[i] + " ");
}

class BB {
    public void array(int[] arr) {
        //修改数组内容arr[0]=200
        arr[0] = 200;
        System.out.println("修改arr[0]=200之后的arr");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
=================================
原先Array
1 2 3 
修改arr[0]=200之后的arr
200 2 3 
调用方法后Array
200 2 3 
```




