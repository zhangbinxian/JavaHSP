### idea快捷键介绍
- ctrl+x delete当前行
- ctrl+d 复制当前行
- ctrl+z 撤回
- ctrl+y 返回上一个撤回
- alt+shift+上下箭头 移动当前行

- ctrl+上下箭头 移动页面
- ctrl+左右箭头 跨单词移动
- ctrl+alt+l 代码快速格式化

- ctrl+h 查看类的继承关系
- .var 快速生成接收变量名
### 包(package com.xxx)
包的本质 创建不同的文件夹来保持类文件
- 区分相同名称的类
- 当类很多时，可以很好的管理类
- 控制访问范围
- 一个类最多一个package，放在最上面
#### 包命名规则
- 只能包含数字，下划线，小圆点
- 不能数字开头
- 不能是关键字或保留字
#### 包命名规范
- 一般是小写字母+小圆点
- com.公司名.项目名.业务模块名 
- com.sina.crm.user
- com.sina.crm.order
- com.sina.crm.utils

### java常用的包
- java.lang.*;  lang包是基础包，默认导入，不需要在引入
- java.util.*;  util包，工具类包，例如Scanner
- java.net.*;   网络包，网络开发
- java.wat.*;   界面开发，GUI

### 访问修饰符
java提供四种访问修饰符，用于控制方法和属性(成员变量)的访问权限(范围)
1. 公开   public，对外公开
2. 受包含  protected，对子类和同一个包当中的类公开
3. 默认   没有修饰符，向同一个包中的类公开
4. 私有   private，只对本类本身可以访问，不对外公开


下面表格竖向使用

|1|访问级别|访问修饰符|同类|同包|不同包子类|不同包其他类|
|---|---|---|---|---|---|---|
|2|公开|public|✓|✓|✓|✓|
|3|受保护|protected|✓|✓|✓|✗|
|4|默认|没有修饰符|✓|✓|✗|✗|
|5|私有|private|✓|✗|✗|✗|

#### 使用注意事项
1. 访问修饰符用来修饰类中的属性，成员方法以及类
2. 只有默认和public才能修饰类，并遵循上述表格访问特点
3. 子类
4. 成员方法的访问规则和属性一致

### 面向对象编程(封装,继承,多态)
- 封装(encapsulation)就是把抽象出来的数据(属性)和对数据的操作(方法)封装在一起，
数据被保护在内部，程序的其他部分只有被授权的操作(方法),才能对数据进行操作
- 封装
1. 隐藏实现细节
2. 可以对数据经行验证，保证安全合理
- 继承(extends)可以解决代码复用，当多个类存在相同的属性(变量)和方法时，
可以从当中抽取父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，
只需要```extends```来声明继承父类
- 继承
1. 子类自动拥有父类定义的属性和方法
2. 父类又叫超类，基类
3. 子类又叫派生类
4. 继承提高了代码的复用性，扩展性和维护性

- 多态(polymorphic)解决代码复用性不高，不利于代码维护
- 多态，方法或对象具有多种形态，多态建立在封装和继承基础之上
1. 方法的多态PolyMethod.java
2. 对象的多态PolyObject.java


#### 封装的实现步骤
1. 将属性进行私有化private，不能直接修改属性
2. 提供一个公共的set方法，用于对属性判断并复制
3. 提供一个公共的get方法，用于获取属性的值
```java
public class qq {
    private String username;
    private String password;

    public qq(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

#### 继承语法
```java
class 子类 extends 父类{
    
}
```    
#### 继承的细节
1. 子类继承了所有的属性和方法，但私有属性和方法不能在子类直接访问，需要通过公共的方法去访问
2. 子类必须调用父类的构造器，完成父类的初始化
3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的```无参构造器```，
如果父类没有提供无参构造器，则必须在子类的构造器中使用spuer去指定使用父类的哪个构造器完成对父类的初始化工作，
否则，编译不会通过
4. 如果希望指定去调用父类的某个构造器，则显示的调用一些: super(参数列表)
5. super在使用时，需要放在构造器第一行
6. super()和this()都只能放在构造器第一行，所以这两个方法不能共存在一个构造器当中
7. java所有的类都是Object类的子类，Object是所有类的父类
8. 父类构造器的调用不限于直接父类！，将一直往上追溯直到Object类(顶级父类)
9. 子类最多只能继承一个父类(指直接继承),java是单继承机制
10. 不能滥用继承，子类和父类之间必须满足is-a的逻辑
#### 继承的本质
当子类创建好对象后，建立查找的关系

#### super关键字
- super代表父类的引用，用于访问父类的属性，方法，构造器、
- 访问父类的属性，但不能访问父类的private属性，super.属性名
- 访问父类的方法，但不能访问父类的private方法，super.方法名(参数列表)
- 访问父类的构造器 super(参数列表)，super只能放在第一句
#### super细节
- 调用父类的构造器的好处(分工明确，父类属性由父类初始化，子类的属性由子类初始化)
- 当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super，如果没有重名，使用super，this，直接访问是一样的效果
- super的访问不限于直接访问父类,如果爷爷类和本类中有同名的成员,也可以使用super去访问爷爷类的成员;如果多个基类当中都有同名的成员,使用super访问遵循就近原则A->B->C

### super和this的比较
|NO|区别点|thhis|super|
|---|---|---|---|
|1|访问属性|访问本类中的属性,如果本类没有,则从父类中继续查找|从父类开始查找属性|
|2|调用方法|访问本类中的方法,如果本类没有,则从父类中继续查找|从父类开始查找方法|
|3|调用构造器|调用本类构造器,必须放在构造器第一行|调用父类构造器,必须放在构造器第一行|
|4|特殊|表示当前对象|子类中访问父类对象|

### 方法重写/覆盖(override)
方法覆盖就是子类有一个方法，和父类的某个方法的```名称```，```返回类型```，```参数```一样，那么我们就说子类的这个方法覆盖了父类的方法
#### 方法重写细节
- 子类的方法的```名称```，```参数```和父类一样
- 子类的返回值类型和父类方法的返回值类型一样，或者是父类返回类型的子类。
比如父类是Object，子类方法返回值类型是String。
```java
public Object getinfo(){}   //父类
public String getinfo(){}   //子类
```
- 子类方法不能缩小父类方法的访问权限 public > protected > 默认 > private
```java
void sayOK(){}              //父类
public void sayOK(){}       //子类
```
|名称|发生范围|方法名|参数列表|返回值类型|修饰符|
|---|---|---|---|---|---|
|重载(overload)|本类|必须一样|参数类型，个数，顺序至少一个不同|无要求|无要求|
|重写(override)|父子类|必须一样|参数相同|子类重写返回值类型和父类一样or父类的子类|子类重写方法不能缩小父类方法的访问范围|

### 多态的具体体现
- 多态，方法或对象具有多种形态，多态建立在封装和继承基础之上
1. 方法的多态PolyMethod.java
2. 对象的多态PolyObject.java

对象的多态
- 一个对象的编译类型和运行类型可以不一致
- 编译类型在定义对象时，就确定了，不能改变
- 运行类型是可以改变的
- 编译类型看定义时 = 号 的左边，运行类型看 = 号的右边
```java
Animal animal=new Dog();        
//animal编译类型是Animal，运行类似是Dog

animal=new Cat();
//animal的运行类型变成了Cat，编译类型仍然是Animal
```
#### 多态注意事项和细节
多态的前提是:两个对象(类)存在继承关系<br>
多态的向上转型
1. 本质：父类的引用类型指向了子类的对象
2. 语法：父类类型 引用名 = new 子类类型();
3. 特点：编译类型看左边，运行类型看右边
> 可以调用父类的所有成员(需要遵循访问权限)<br>
  不能调用子类中特有成员<br>
  最终运行结果看子类的具体实现,从子类开始查找方法，与之前的查找调用规则一致

多态的向下转型
1. 语法：子类类型 引用名 = (子类对象)父类引用
2. 只能强转父类的引用，不能强转父类的对象
3. 要求父类的引用必须指向的是目标类型的对象
4. 可以调用子类类型当中的所有成员

属性没有重写之说！属性的值看编译类型

instanceOf比较操作符，用于判断对象的```运行类型```是否为XX类型或者XX类型的子类型

### java动态绑定机制(非常重要！！！)
1. 当调用对象方法的时候，该方法会和对象的内存地址/运行类型绑定
2. 当调用对象属性时候，没有动态绑定机制，哪里声明，哪里使用

### Object类
equals方法
1. == 既可以判断基本数据类型，又可以判断引用数据类型
2. == 如果判断基本数据类型，判断的是值是否相等
3. == 如果判断引用数据类型，判断的是地址是否相等，即判断是不是同一个对象
